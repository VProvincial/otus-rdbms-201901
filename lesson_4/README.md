
# Урок 4 -  Компоненты современной СУБД 

## Задача:

Добавляем в модель данных дополнительные индексы и ограничения

Обновленная ERP модель данных: */lesson_4/afiash_v4.png*

#### Анализ возможных запросов/отчетов в понимании задач бизнес-процессов:

1. Таблица **booking** - забронированные билеты.    
    1.1 Различные варианты поиск купленных билетов в зависимости от статуса брони, id сеанса, id клиента  
    1.2 Поиск купленного билета в кинотеатре по его номеру
2. Таблица **hall** - справочник кинозалов и **feature_hall** - значения характеристик кинозала  
    2.1. Поиск/вывод кинозалов кинотеара, вместе с его характеристиками  
3. Таблица **seans** - киносеансы  
3.1. Поиск сеансов по фильму  
3.2. Поиск сеансов по кинотеатру  
3.3. Отчет сколько и на какую сумму было успешно продано билетов по каждому кинотеатру в заданный период дат (Название кинотеатра, кол-во билетов, сумма)

#### Описание ограничений:
1. Почти для каждой табл добавил колонку **id**, вкачестве первичного ключа, кроме табл **feature_hall**, 
там ключ будет составной из колонок **id_feature**, **id_hall**, т.к. эти поля однозначно идентифицируют запись в таблице. 

#### Описание индексов:
#####  1.1 Различные варианты поиск купленных билетов в зависимости от статуса брони, id сеанса, id клиента
* Поля индекса: **id_status**, **id_seans**, **id_client**, **insert_date**
    * **id_status** - поставил его на первое место потому что статус будет использоваться почти во всех запросах 
    и второй момент - это поле с самой сильной координальностью в таблице
    * **id_seans** и **id_client** - это внешние ключи, их наличие в индексе помогает БД с join'ами, 
    но то что эти поля находятся в середине индекса, скорее всего БД не сможет их использовать?
    * **insert_date** - дата создания брони может быть использована в запросах, но очень редко, 
    имеет смысл его использовать в индексе? но это поле может быть использовано в отчете из пункта 3.3 
    * Вопросы:
        * Есть ощущение более существенный эффект даст выделение полей **id_seans** и **id_client** в отдельные индексы, 
        что даст весомый плюс к join'ам, а **id_status** - оставить отдельным полем, что и так поможет в выборке данных, 
        но тогда в индексе терается кейс описанный в п 1.17
* Поля индекса: **id_status** - т.к. является внешним ключом
* Поля индекса: **id_seans** - т.к. является внешним ключом
* Поля индекса: **id_client** - т.к. является внешним ключом
#####  1.2 Поиск купленного билета в кинотеатре по его номеру
* Поля индекса: *ticket* 
    * Хочется добавить к нему **id_seans** или **id_client**, но тогда индекс будет дублровать другие индексы, 
    и не всегда эти поля могут присутствовать в запросе 
#####  2.1 Поиск/вывод кинозалов кинотеара, вместе с его характеристиками
* Поля индекса: **id_hall** - одино поле из табл **feature_hall**, т.к. является внешним ключом
* Поля индекса: **id_feature** - одино поле из табл **feature_hall**, т.к. является внешним ключом
#####  3.1-2 Поиск сеансов по фильму и кинотеатру
* Поля индекса: **id_film**, **fininshed**, **id_hall**
    * **id_film** - поставил первым, т.к. всегда поле будет участвовать в фильтре, + поле позволит использовать индекс в join
    * **id_fininshed** - поставил вторым, т.к. не всегда его значение будет в where, 
    но при координальности = 2 возможно стоит добавить его первым и всегда что-либо указать для него в запросе
    * **id_hall** - это колонка позволит фильтровать сеансы по кинотеатру через кинозалы
    * я бы еще добавил в табл **seans** колонку **id_company** (id кинотеатра) + добавил его в индекс, 
    да это денормализция модели данных + избыточность, 
    но это значительно ускорит выборку данных по кинотеатру и исключит использование join'ов
    * Вопрос:
        * Возможно ли сделать *trigger*, который будет контролировать колонку **id_company** в соответствии с колонкой **id_hall**, 
        таким финтом мы уберем проблему ссылочной целостности, 
        или здесь правильнее будет использовать constraint а поле заполнять самому на уровне приложения?
        *  Какие ещё есть варианты решения оптимизации подобных проблем, 
        когда для оптимизации запроса есть потребность добавить колонку добавляющую избыточность и денормализацию модели данных?
         
#####  Отчет сколько и на какую сумму было успешно продано билетов по каждому кинотеатру в заданный период дат (Название кинотеатра, кол-во билетов, сумма)
* Поля индекса: **id_seans**, **id_status**, **price**, **insert_date**
    * выбрал эти поля потому что именно они используются в аггрегации и группировке
    * **id_seans** поставил первым потому что по нему будет производиться выборка аггрегированных данных 
    для дальнейшей группировки по id компании, т.к. на уровне табл **booking** мы можешь получить данные только по сеансам
    * для оптимизации группировки по компании имеет смысл добавить в табл колонку **id_company**, совсеми вытекающими

##### Общие вопросы: 
1. Если мы ищем данные которых нет в индексе, фильтруем по полям которые есть в индексе, 
но в select участвуют другие поля которых нет в индексе
что в этой ситуации делает БД и как можно оптимизировать подобные запросы?
2. я немного запутался в координальности, если число уникальных значений мало, 
то это говорит о том что координальность колонки сильная и что с этим делать?) это хорошо или плохо? 
я так понимаю что для bitmap это большой плюс, но для b-tree лучше использовать уникальность полей, 
т.е. по сути обратная характеристика координальности, когда и как нужно использовать координальность?
3. Нужно ли создавать для каждого внешнего ключа свой индекс? 
Читал в других источниках что это дает плюс для поддержке ссылочной целостности данных и для оптимизации join'ов, 
т.к. БД будет их часто использовать для связи таблиц.
4. Если мы имеем индекс1 из полей field1, field2, field3. В запросе в блоке where будут участвовать поля field1 и field2 - такой запрос будет использовать индекс1? 
Стоит проектировать индексы исходи из подобных рассуждений?
5. Для общего понимаю координальности колонки такой вопрос: будет ли идеальным решением в контексте производительности
подбирать индексы по силе их координальности? т.е. по-порядку, например, пол, страна, город и т.д.


        


2.1. 

Здесь самой высокая коородинальность у колонки status, его использование в